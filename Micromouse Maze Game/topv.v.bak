`default_nettype none
// ====================================================================
// Micromouse_Game_FAST (DE1-SoC + vga_adapter)
// - FAST_BUILD=1 (from .qsf) -> 320x240, COLOR_DEPTH=6 (2-2-2 RGB)
// - otherwise -> 640x480, COLOR_DEPTH=9 (3-3-3 RGB)
// ====================================================================
module topv(
    input  wire        CLOCK_50,
    input  wire [3:0]  KEY,          // KEY[0]=reset_n, KEY[1]=Up, KEY[2]=Right, KEY[3]=Left
    input  wire [9:0]  SW,           // SW0=Down, SW[9:1] contribute to seed (optional)

    output wire [9:0]  LEDR,

    // VGA adapter pins (match your working vga_adapter project)
    output wire [7:0]  VGA_R,
    output wire [7:0]  VGA_G,
    output wire [7:0]  VGA_B,
    output wire        VGA_HS,
    output wire        VGA_VS,
    output wire        VGA_BLANK_N,
    output wire        VGA_SYNC_N,
    output wire        VGA_CLK
);

    // --------------------- Build mode params -------------------------
`ifdef FAST_BUILD
    localparam integer H_PIX = 320;
    localparam integer V_PIX = 240;
    localparam integer CD    = 6;    // 2-2-2 RGB
`else
    localparam integer H_PIX = 640;
    localparam integer V_PIX = 480;
    localparam integer CD    = 9;    // 3-3-3 RGB
`endif

    // --------------------- Reset & clocks ----------------------------
    wire reset = ~KEY[0];

    // Slow logic tick for maze/player (keeps moves reasonable)
    reg [26:0] divclk;
    always @(posedge CLOCK_50 or posedge reset) begin
        if (reset) divclk <= 27'd0;
        else       divclk <= divclk + 27'd1;
    end
    wire tick = divclk[7];           // ~390 kHz

    // Heartbeat for blink effects
    reg [25:0] hb;
    always @(posedge CLOCK_50 or posedge reset) begin
        if (reset) hb <= 26'd0;
        else       hb <= hb + 26'd1;
    end

    // --------------------- Maze generator ----------------------------
    wire [15:0] seed16 = {6'b0, SW}; // (unused if you dropped in the fixed maze)
    wire        maze_done;
    wire [624:0] maze_bits;          // PATH=1, WALL=0, index = y*25 + x

    maze_generator u_gen (
        .clk   (tick),
        .reset (reset),
        .seed  (seed16),
        .done  (maze_done),
        .maze  (maze_bits)
    );

    // --------------------- Player controller -------------------------
    // Direction vector {LEFT, DOWN, RIGHT, UP} (active-high)
    wire up    = ~KEY[1];
    wire right = ~KEY[2];
    wire left  = ~KEY[3];
    wire down  =  SW[0];

    reg [3:0] direction;
    always @(posedge CLOCK_50 or posedge reset) begin
        if (reset)         direction <= 4'b0000;
        else if (maze_done) direction <= {left, down, right, up};
        else               direction <= 4'b0000;
    end

    wire [7:0] player_x;
    wire [7:0] player_y;

    player_controller u_player (
        .clk            (tick),
        .load           (maze_done),
        .reset          (reset),
        .maze           (maze_bits),
        .input_direction(direction),
        .player_x_out   (player_x),
        .player_y_out   (player_y)
    );

    // --------------------- Win logic --------------------------------
    localparam [4:0] TREASURE_X = 5'd23;
    localparam [4:0] TREASURE_Y = 5'd23;

    wire at_treasure = (player_x[4:0]==TREASURE_X) && (player_y[4:0]==TREASURE_Y);
    reg  win_latched;
    always @(posedge CLOCK_50 or posedge reset) begin
        if (reset)         win_latched <= 1'b0;
        else if (at_treasure) win_latched <= 1'b1;
    end

    // --------------------- Raster counters ---------------------------
`ifdef FAST_BUILD
    // 320 x 240
    reg [8:0] px;  // 0..319
    reg [7:0] py;  // 0..239
`else
    // 640 x 480
    reg [9:0] px;  // 0..639
    reg [8:0] py;  // 0..479
`endif

    always @(posedge CLOCK_50 or posedge reset) begin
        if (reset) begin
            px <= 'd0; py <= 'd0;
        end else begin
            if (px == H_PIX-1) begin
                px <= 'd0;
                py <= (py == V_PIX-1) ? 'd0 : (py + 1'b1);
            end else begin
                px <= px + 1'b1;
            end
        end
    end

    // --------------------- Maze mapping (centered) -------------------
    localparam integer CELL_SIZE = (H_PIX==640) ? 16 : 12;    // 400 or 300 px wide
    localparam integer START_X   = (H_PIX - 25*CELL_SIZE)/2;
    localparam integer START_Y   = (V_PIX - 25*CELL_SIZE)/2;

    wire in_maze_box =
        (px >= START_X) && (px < START_X + 25*CELL_SIZE) &&
        (py >= START_Y) && (py < START_Y + 25*CELL_SIZE);

    wire [9:0] rel_x = px - START_X;
    wire [9:0] rel_y = py - START_Y;

    wire [4:0] tile_x = rel_x / CELL_SIZE;
    wire [4:0] tile_y = rel_y / CELL_SIZE;

    wire [9:0] maze_index = tile_y * 10'd25 + tile_x;

    // Border for aesthetics
    wire on_border = in_maze_box && (
        (px == START_X) ||
        (px == START_X + 25*CELL_SIZE - 1) ||
        (py == START_Y) ||
        (py == START_Y + 25*CELL_SIZE - 1)
    );

    // Player & treasure cells
    wire is_player_cell   = in_maze_box && (tile_x == player_x[4:0]) && (tile_y == player_y[4:0]);
    wire is_treasure_cell = in_maze_box && (tile_x == TREASURE_X)     && (tile_y == TREASURE_Y);

    // --------------------- Colors (width depends on CD) --------------
    wire [CD-1:0] color;

`ifdef FAST_BUILD
    // 2-2-2 RGB
    localparam [CD-1:0] C_BLACK = 6'b00_00_00;
    localparam [CD-1:0] C_WHITE = 6'b11_11_11;
    localparam [CD-1:0] C_RED   = 6'b11_00_00;
    localparam [CD-1:0] C_CYAN  = 6'b00_11_11;
    localparam [CD-1:0] C_GOLD  = 6'b11_11_00;
    localparam [CD-1:0] C_DGREY = 6'b01_01_01;
`else
    // 3-3-3 RGB
    localparam [CD-1:0] C_BLACK = 9'b000_000_000;
    localparam [CD-1:0] C_WHITE = 9'b111_111_111;
    localparam [CD-1:0] C_RED   = 9'b111_000_000;
    localparam [CD-1:0] C_CYAN  = 9'b000_111_111;
    localparam [CD-1:0] C_GOLD  = 9'b111_111_000;
    localparam [CD-1:0] C_DGREY = 9'b001_001_001;
`endif

    wire blink = hb[24]; // ~3 Hz when win

    reg [CD-1:0] color_sel;
    always @* begin
        if (win_latched && blink)       color_sel = C_CYAN;     // flash
        else if (on_border)             color_sel = C_RED;
        else if (is_player_cell)        color_sel = C_CYAN;
        else if (is_treasure_cell)      color_sel = C_GOLD;
        else if (in_maze_box)           color_sel = (maze_bits[maze_index]) ? C_BLACK : C_RED;
        else                            color_sel = C_BLACK;
    end
    assign color = color_sel;

    // --------------------- Drive vga_adapter -------------------------
`ifdef FAST_BUILD
    // Adapter expects x[8:0], y[7:0] in 320x240 mode
    wire [8:0] X_BUS = px[8:0];
    wire [7:0] Y_BUS = py[7:0];
`else
    // Adapter expects x[9:0], y[8:0] in 640x480 mode
    wire [9:0] X_BUS = px[9:0];
    wire [8:0] Y_BUS = py[8:0];
`endif

    vga_adapter VGA (
        .resetn     (~reset),
        .clock      (CLOCK_50),
        .color      (color),
        .x          (X_BUS),
        .y          (Y_BUS),
        .write      (1'b1),
        .VGA_R      (VGA_R),
        .VGA_G      (VGA_G),
        .VGA_B      (VGA_B),
        .VGA_HS     (VGA_HS),
        .VGA_VS     (VGA_VS),
        .VGA_BLANK_N(VGA_BLANK_N),
        .VGA_SYNC_N (VGA_SYNC_N),
        .VGA_CLK    (VGA_CLK)
    );
`ifdef FAST_BUILD
    defparam VGA.RESOLUTION  = "320x240";
    defparam VGA.COLOR_DEPTH = 6;
`else
    defparam VGA.RESOLUTION  = "640x480";
    defparam VGA.COLOR_DEPTH = 9;
`endif
    // (MIF not needed since we overwrite every pixel each frame)

    // --------------------- LEDs -------------------------------------
    assign LEDR = {maze_done, win_latched, SW[7:0]};

endmodule
`default_nettype wire
